// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

// THIS FILE WAS AUTO-GENERATED BY ./ntcore/generate_topics.py. DO NOT MODIFY

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading;
using NetworkTables.Handles;
using NetworkTables.Natives;
using WPIUtil.Concurrent;
using WPIUtil.Natives;

namespace NetworkTables;

/**
 * NetworkTables Instance.
 *
 * <p>Instances are completely independent from each other. Table operations on one instance will
 * not be visible to other instances unless the instances are connected via the network. The main
 * limitation on instances is that you cannot have two servers on the same network port. The main
 * utility of instances is for unit testing, but they can also enable one program to connect to two
 * different NetworkTables networks.
 *
 * <p>The global "default" instance (as returned by {@link #GetDefault()}) is always available, and
 * is intended for the common case when there is only a single NetworkTables instance being used in
 * the program.
 *
 * <p>Additional instances can be created with the {@link #create()} function. A reference must be
 * kept to the NetworkTableInstance returned by this function to keep it from being garbage
 * collected.
 */
public sealed partial class NetworkTableInstance : IDisposable
{
    public static readonly int kDefaultPort3 = 1735;
    public static readonly int kDefaultPort4 = 5810;

    private NetworkTableInstance() : this(NtCore.GetDefaultInstance(), false) { }

    private NetworkTableInstance(NtInst inst, bool owned)
    {
        Handle = inst;
        m_owned = owned;
        m_listeners = new(this);
    }

    public NtInst Handle { get; private set; }

    private readonly bool m_owned;

    public void Dispose()
    {
        if (m_owned & Handle.Handle != 0)
        {
            NtCore.DestroyInstance(Handle);
            Handle = default;
        }
    }

    public bool IsValid => Handle.Handle != 0;

    private static readonly Lazy<NetworkTableInstance> s_defaultInstance = new();

    public static NetworkTableInstance Default => s_defaultInstance.Value;

    public static NetworkTableInstance Create()
    {
        return new(NtCore.CreateInstance(), true);
    }

    public Topic GetTopic(string name)
    {
        Topic topic = m_topics.GetOrAdd(name, n =>
        {
            NtTopic topicHandle = NtCore.GetTopic(Handle, name);
            Topic topic = new(this, topicHandle);
            m_topicsByHandle.TryAdd(topicHandle, topic);
            return topic;
        });
        return topic;
    }

    private Topic[] TopicHandlesToTopics(NtTopic[] handles)
    {
        Topic[] topics = new Topic[handles.Length];
        for (int i = 0; i < handles.Length; i++)
        {
            topics[i] = GetCachedTopic(handles[i]);
        }
        return topics;
    }

    internal Topic GetCachedTopic(NtTopic handle)
    {
        Topic topic = m_topicsByHandle.GetOrAdd(handle, n =>
                {
                    Topic topic = new(this, handle);
                    return topic;
                });
        return topic;
    }

    public Topic[] GetTopics()
    {
        return TopicHandlesToTopics(NtCore.GetTopics(Handle, "", NetworkTableType.Unassigned));
    }

    public Topic[] GetTopics(string prefix)
    {
        return TopicHandlesToTopics(NtCore.GetTopics(Handle, prefix, NetworkTableType.Unassigned));
    }

    public Topic[] GetTopics(string prefix, NetworkTableType types)
    {
        return TopicHandlesToTopics(NtCore.GetTopics(Handle, prefix, types));
    }

    public Topic[] GetTopics(string prefix, string[] types)
    {
        return TopicHandlesToTopics(NtCore.GetTopics(Handle, prefix, types));
    }

    public TopicInfo[] GetTopicInfo()
    {
        return NtCore.GetTopicInfos(Handle, "", NetworkTableType.Unassigned);
    }

    public TopicInfo[] GetTopicInfo(string prefix)
    {
        return NtCore.GetTopicInfos(Handle, prefix, NetworkTableType.Unassigned);
    }

    public TopicInfo[] GetTopicInfo(string prefix, NetworkTableType types)
    {
        return NtCore.GetTopicInfos(Handle, prefix, types);
    }

    public TopicInfo[] GetTopicInfo(string prefix, string[] types)
    {
        return NtCore.GetTopicInfos(Handle, prefix, types);
    }

    private class ListenerStorage(NetworkTableInstance inst) : IDisposable
    {
        private readonly object m_lock = new();
        private readonly Dictionary<NtListener, Action<NetworkTableEvent>> m_listeners = new();
        private Thread? m_thread;
        private NtListenerPoller m_poller;
        private bool m_waitQueue;
        private readonly Event m_waitQueueEvent = new();
        private readonly NetworkTableInstance m_inst = inst;

        public NtListener Add(string[] prefixes, EventFlags eventKinds, Action<NetworkTableEvent> listener)
        {
            lock (m_lock)
            {
                if (m_poller.Handle == 0)
                {
                    m_poller = NtCore.CreateListenerPoller(m_inst.Handle);
                    StartThread();
                }
                NtListener h = NtCore.AddListener(m_poller, prefixes, eventKinds);
                m_listeners.Add(h, listener);
                return h;
            }
        }

        public NtListener Add(NtInst handle, EventFlags eventKinds, Action<NetworkTableEvent> listener)
        {
            lock (m_lock)
            {
                if (m_poller.Handle == 0)
                {
                    m_poller = NtCore.CreateListenerPoller(m_inst.Handle);
                    StartThread();
                }
                NtListener h = NtCore.AddListener(m_poller, handle, eventKinds);
                m_listeners.Add(h, listener);
                return h;
            }
        }

        public NtListener Add<T>(T handle, EventFlags eventKinds, Action<NetworkTableEvent> listener) where T : struct, INtEntryHandle
        {
            lock (m_lock)
            {
                if (m_poller.Handle == 0)
                {
                    m_poller = NtCore.CreateListenerPoller(m_inst.Handle);
                    StartThread();
                }
                NtListener h = NtCore.AddListener(m_poller, handle, eventKinds);
                m_listeners.Add(h, listener);
                return h;
            }
        }

        public void Remove(NtListener listener)
        {
            lock (m_lock)
            {
                m_listeners.Remove(listener);
            }
            NtCore.RemoveListener(listener);
        }

        public void Dispose()
        {
            if (m_poller.Handle != 0)
            {
                NtCore.DestroyListenerPoller(m_poller);
                m_poller = default;
            }
        }

        private void StartThread()
        {
            m_thread = new Thread(() =>
            {
                bool wasInterrupted = false;
                ReadOnlySpan<int> handles = [m_poller.Handle, m_waitQueueEvent.Handle];
                Span<int> signaledStorage = [0, 0];
                while (true)
                {
                    var signaled = SynchronizationNative.WaitForObjects(handles, signaledStorage);
                    if (signaled.Length == 0)
                    {
                        lock (m_lock)
                        {
                            if (m_waitQueue)
                            {
                                m_waitQueue = false;
                                Monitor.PulseAll(m_lock);
                            }
                        }
                        wasInterrupted = true;
                        break;
                    }
                    foreach (NetworkTableEvent evnt in NtCore.ReadListenerQueue(m_poller))
                    {
                        Action<NetworkTableEvent>? listener;
                        lock (m_lock)
                        {
                            if (!m_listeners.TryGetValue(evnt.ListenerHandle, out listener))
                            {
                                listener = null;
                            }
                        }
                        try
                        {
                            listener?.Invoke(evnt);
                        }
                        catch (Exception ex)
                        {
                            Console.Error.WriteLine($"Unhandled exception during listener callback: {ex}");
                        }
                    }
                    lock (m_lock)
                    {
                        if (m_waitQueue)
                        {
                            m_waitQueue = false;
                            Monitor.PulseAll(m_lock);
                        }
                    }
                }
                lock (m_lock)
                {
                    if (!wasInterrupted)
                    {
                        NtCore.DestroyListenerPoller(m_poller);
                    }
                    m_poller = default;
                }

            })
            {
                Name = "NTListener",
                IsBackground = true
            };
            m_thread.Start();
        }

        public bool WaitForQueue(TimeSpan? timeout)
        {
            lock (m_lock)
            {
                if (m_poller.Handle != 0)
                {
                    m_waitQueue = true;
                    m_waitQueueEvent.Set();
                }
                while (m_waitQueue)
                {
                    if (!timeout.HasValue)
                    {
                        Monitor.Wait(m_lock);
                    }
                    else
                    {
                        return Monitor.Wait(m_lock, timeout.Value);
                    }
                }
            }
            return true;
        }
    }

    private readonly ListenerStorage m_listeners;

    public void RemoveListener(NtListener listener)
    {
        m_listeners.Remove(listener);
    }

    public bool WaitForListenerQueue(TimeSpan? timeout)
    {
        return m_listeners.WaitForQueue(timeout);
    }

    public NtListener AddConnectionListener(bool immediateNotify, Action<NetworkTableEvent> listener)
    {
        EventFlags flags = EventFlags.Connection;
        if (immediateNotify)
        {
            flags |= EventFlags.Immediate;
        }
        return m_listeners.Add(Handle, flags, listener);
    }

    public NetworkMode GetNetworkMode() {
        return NtCore.GetNetworkMode(Handle);
    }

    public void StartLocal() {
        NtCore.StartLocal(Handle);
    }

    public void StopLocal() {
        NtCore.StopLocal(Handle);
    }

    private readonly ConcurrentDictionary<string, Topic> m_topics = new();
    private readonly ConcurrentDictionary<NtTopic, Topic> m_topicsByHandle = new();
}
